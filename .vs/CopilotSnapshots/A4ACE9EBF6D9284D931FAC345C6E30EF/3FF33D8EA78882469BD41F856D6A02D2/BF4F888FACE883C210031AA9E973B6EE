#include <iostream>
#include <opencv2/opencv.hpp>
#include <cuda_runtime.h>
#include <device_launch_parameters.h>
#include <cmath>

#pragma comment(lib, "opencv_world4120.lib")

using namespace cv;
using namespace std;

// ==========================================
// 0. 通用工具
// ==========================================
// 限制数值范围在 [min, max] 之间
__device__ inline float clamp_val(float v, float min_v, float max_v) {
    return fmaxf(min_v, fminf(v, max_v));
}

// ==========================================
// 1. 预处理核函数 (亮度/对比度 + 桑原滤波)
// ==========================================
// 作用：让图片变亮、对比度变高，并产生油画般的涂抹感，去除噪点
__global__ void preprocess_kernel(const uchar3* __restrict__ in, uchar3* out, int width, int height,
    float brightness, float contrast, int k_size) {
    int x = blockIdx.x * blockDim.x + threadIdx.x;
    int y = blockIdx.y * blockDim.y + threadIdx.y;
    if (x >= width || y >= height) return;

    // 定义桑原滤波的 4 个区域偏移 (左上, 右上, 左下, 右下)
    int r = k_size / 2;
    int regions[4][4] = {
        {-r, -r, 0, 0}, {0, -r, r, 0}, {-r, 0, 0, r}, {0, 0, r, r}
    };

    float min_variance = 1e9f;
    float3 final_color = { 0.0f, 0.0f, 0.0f };

    // 遍历 4 个区域，计算均值和方差
    for (int k = 0; k < 4; ++k) {
        float3 mean = { 0,0,0 };
        float3 sq_mean = { 0,0,0 };
        int count = 0;

        for (int dy = regions[k][1]; dy <= regions[k][3]; ++dy) {
            for (int dx = regions[k][0]; dx <= regions[k][2]; ++dx) {
                // 边界处理
                int px = clamp_val(x + dx, 0, width - 1);
                int py = clamp_val(y + dy, 0, height - 1);

                // 读取像素
                uchar3 p = in[py * width + px];

                // --- 亮度与对比度增强 ---
                float3 c;
                // 先归一化到 0-1，调整亮度，再减0.5调整对比度，最后加回0.5
                c.x = clamp_val(((p.x / 255.0f * brightness) - 0.5f) * contrast + 0.5f, 0.0f, 1.0f);
                c.y = clamp_val(((p.y / 255.0f * brightness) - 0.5f) * contrast + 0.5f, 0.0f, 1.0f);
                c.z = clamp_val(((p.z / 255.0f * brightness) - 0.5f) * contrast + 0.5f, 0.0f, 1.0f);

                mean.x += c.x; mean.y += c.y; mean.z += c.z;
                sq_mean.x += c.x * c.x; sq_mean.y += c.y * c.y; sq_mean.z += c.z * c.z;
                count++;
            }
        }

        mean.x /= count; mean.y /= count; mean.z /= count;
        sq_mean.x /= count; sq_mean.y /= count; sq_mean.z /= count;

        // 方差 = E[X^2] - (E[X])^2
        float total_var = (sq_mean.x - mean.x * mean.x) +
            (sq_mean.y - mean.y * mean.y) +
            (sq_mean.z - mean.z * mean.z);

        // 找方差最小（最平滑）的区域
        if (total_var < min_variance) {
            min_variance = total_var;
            final_color = mean;
        }
    }

    // 输出预处理后的像素
    out[y * width + x] = make_uchar3(final_color.x * 255, final_color.y * 255, final_color.z * 255);
}

// ==========================================
// 2. 像素化核函数 (分层统计)
// ==========================================
// 作用：基于亮度分层，统计主导颜色，填充马赛克块
__global__ void pixel_effect_kernel(const uchar3* __restrict__ in, uchar3* out, int width, int height, int pixel_size, int kernel_size) {
    // 线程索引对应的是“马赛克块”，而不是像素
    int bx = blockIdx.x * blockDim.x + threadIdx.x;
    int by = blockIdx.y * blockDim.y + threadIdx.y;

    // 块的中心点坐标
    int cx = bx * pixel_size + pixel_size / 2;
    int cy = by * pixel_size + pixel_size / 2;

    if (cx >= width || cy >= height) return;

    const int NUM_BINS = 4;
    int bin_counts[NUM_BINS] = { 0 };
    int3 bin_sums[NUM_BINS] = { {0,0,0} };
    int r = kernel_size / 2;

    // 统计中心点周围 kernel_size 范围内的颜色分布
    for (int dy = -r; dy <= r; ++dy) {
        for (int dx = -r; dx <= r; ++dx) {
            int px = cx + dx;
            int py = cy + dy;

            // 简单的边界Clamp
            if (px < 0) px = 0; else if (px >= width) px = width - 1;
            if (py < 0) py = 0; else if (py >= height) py = height - 1;

            uchar3 p = in[py * width + px];
            int intensity = (p.x + p.y + p.z) / 3;
            int bin_idx = (intensity * NUM_BINS) / 256;
            if (bin_idx >= NUM_BINS) bin_idx = NUM_BINS - 1;

            bin_counts[bin_idx]++;
            bin_sums[bin_idx].x += p.x;
            bin_sums[bin_idx].y += p.y;
            bin_sums[bin_idx].z += p.z;
        }
    }

    // 找出像素最多的那个亮度层
    int max_count = -1;
    int best_bin = 0;
    for (int i = 0; i < NUM_BINS; ++i) {
        if (bin_counts[i] > max_count) {
            max_count = bin_counts[i];
            best_bin = i;
        }
    }

    // 计算该层的平均色
    uchar3 final_color = { 0, 0, 0 };
    if (max_count > 0) {
        final_color.x = bin_sums[best_bin].x / max_count;
        final_color.y = bin_sums[best_bin].y / max_count;
        final_color.z = bin_sums[best_bin].z / max_count;
    }

    // 填色：把计算出的颜色填满整个马赛克块
    int start_x = bx * pixel_size;
    int start_y = by * pixel_size;
    for (int dy = 0; dy < pixel_size; ++dy) {
        for (int dx = 0; dx < pixel_size; ++dx) {
            int px = start_x + dx;
            int py = start_y + dy;
            if (px < width && py < height) {
                out[py * width + px] = final_color;
            }
        }
    }
}
void cpu_function() {
    
}

// ==========================================
// 3. 主函数
// ==========================================
int main() {
    // --- 参数配置 ---
    string imgPath = "input2.jpg";
    int pixel_size = 4;   // 马赛克大小
    int kernel_size = 5;  // 像素化时的平滑范围

    // 预处理参数
    float brightness = 1.1f; // 亮度增强 (1.0 不变)
    float contrast = 1.2f;   // 对比度增强 (1.0 不变)
    int kuwahara_size = 5;   // 油画滤镜范围 (奇数)

    // 1. 读取图片
    Mat img_in = imread(imgPath, IMREAD_COLOR);
    if (img_in.empty()) {
        cout << "Error: Load image failed." << endl;
        return -1;
    }
    if (!img_in.isContinuous()) img_in = img_in.clone();

    int w = img_in.cols;
    int h = img_in.rows;
    size_t img_size = w * h * 3 * sizeof(uchar);
    cout << "Image: " << w << "x" << h << endl;

    // 2. 分配显存 (三个缓冲区：输入 -> 临时 -> 输出)
    uchar3* d_in, * d_temp, * d_out;
    cudaMalloc((void**)&d_in, img_size);
    cudaMalloc((void**)&d_temp, img_size); // 存放预处理后的图
    cudaMalloc((void**)&d_out, img_size);  // 存放最终结果

    // 3. 拷贝数据到 GPU
    cudaMemcpy(d_in, img_in.data, img_size, cudaMemcpyHostToDevice);

    // 4. 计算 Grid 大小
    dim3 blockSize(16, 16);

    // Grid 1: 用于预处理 (每个像素一个线程)
    dim3 gridPreprocess((w + blockSize.x - 1) / blockSize.x,
        (h + blockSize.y - 1) / blockSize.y);

    // Grid 2: 用于像素化 (每个马赛克块一个线程)
    dim3 gridPixel((w / pixel_size + blockSize.x - 1) / blockSize.x,
        (h / pixel_size + blockSize.y - 1) / blockSize.y);

    cout << "Start Processing..." << endl;

    // --- 启动流水线 ---

    // Step 1: 预处理 (输入 d_in -> 输出 d_temp)
    preprocess_kernel << <gridPreprocess, blockSize >> > (d_in, d_temp, w, h, brightness, contrast, kuwahara_size);
    cudaDeviceSynchronize(); // 确保第一步做完了

    // Step 2: 像素化 (输入 d_temp -> 输出 d_out)
    // 注意：这里输入变成了 d_temp
    pixel_effect_kernel << <gridPixel, blockSize >> > (d_temp, d_out, w, h, pixel_size, kernel_size);
    cudaDeviceSynchronize();

    cout << "GPU Finished." << endl;

    // 5. 拷贝回 CPU
    Mat img_out = Mat::zeros(h, w, CV_8UC3);
    cudaMemcpy(img_out.data, d_out, img_size, cudaMemcpyDeviceToHost);

    // 6. 保存
    imwrite("result_with_preprocess.png", img_out);
    cout << "Saved to result_with_preprocess.png" << endl;

    // 7. 释放
    cudaFree(d_in);
    cudaFree(d_temp);
    cudaFree(d_out);

    return 0;
}